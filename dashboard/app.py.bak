from __future__ import annotations

import json
import os
import sqlite3
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple

import streamlit as st


# -------------------- Config --------------------

REPO_ROOT = Path(__file__).resolve().parents[1]
DEFAULT_LATEST = REPO_ROOT / "opcua_client" / "latest_data.json"
DEFAULT_DB = REPO_ROOT / "data" / "aas_history.sqlite3"

st.set_page_config(page_title="SCARA Dashboard", layout="wide")


# -------------------- Data access --------------------

def _connect(db_path: Path) -> sqlite3.Connection:
    con = sqlite3.connect(str(db_path))
    con.row_factory = sqlite3.Row
    return con


@st.cache_data(show_spinner=False, ttl=5.0)
def list_paths(db_path: str) -> List[Tuple[str, str]]:
    if not db_path or not Path(db_path).exists():
        return []
    with _connect(Path(db_path)) as con:
        cur = con.cursor()
        cur.execute(
            "SELECT DISTINCT submodel_name, element_path FROM timeseries ORDER BY submodel_name, element_path LIMIT 2000"
        )
        return [(r[0], r[1]) for r in cur.fetchall()]


@st.cache_data(show_spinner=False, ttl=2.0)
def load_timeseries(db_path: str, submodel: str, path: str, limit: int = 300) -> List[Tuple[str, float]]:
    if not db_path or not Path(db_path).exists():
        return []
    with _connect(Path(db_path)) as con:
        cur = con.cursor()
        cur.execute(
            """
            SELECT value, created_at
            FROM timeseries
            WHERE submodel_name = ? AND element_path = ?
            ORDER BY created_at DESC
            LIMIT ?
            """,
            (submodel, path, limit),
        )
        rows = [(str(t), float(v)) for (v, t) in cur.fetchall()]
        rows.reverse()  # oldest -> newest for plotting
        return rows


@st.cache_data(show_spinner=False, ttl=1.0)
def load_latest(latest_path: str) -> Dict[str, Any]:
    p = Path(latest_path)
    if not p.exists():
        return {}
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        # Best-effort: try reading without encoding info
        try:
            return json.loads(p.read_text())
        except Exception:
            return {}


# -------------------- UI helpers --------------------

def kpi_pill(text: str, tone: str = "neutral") -> str:
    palette = {
        "ok": "#16c266",
        "warn": "#f39c12",
        "err": "#e74c3c",
        "neutral": "#7a8598",
    }
    color = palette.get(tone, palette["neutral"])
    return f"<span style='display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);color:{color};'>{text}</span>"


def classify_status(status_text: str) -> str:
    s = (status_text or "").lower()
    if any(x in s for x in ("estop", "fault", "error")):
        return "err"
    if any(x in s for x in ("slow", "manual")):
        return "warn"
    return "ok"


def col_metrics(latest: Dict[str, Any]) -> None:
    op = latest.get("OperationalData", {}) if isinstance(latest, dict) else {}
    tech = latest.get("TechnicalData", {}) if isinstance(latest, dict) else {}

    c1, c2, c3, c4 = st.columns(4)

    with c1:
        st.caption("Working Mode")
        st.markdown(kpi_pill(str(op.get("WorkingMode", "--")), "neutral"), unsafe_allow_html=True)
    with c2:
        st.caption("Robot Status")
        s = str(op.get("RobotStatus", "--"))
        st.markdown(kpi_pill(s, classify_status(s)), unsafe_allow_html=True)
    with c3:
        st.caption("Cycle Time")
        st.markdown(kpi_pill(str(op.get("CycleTime", "--")), "neutral"), unsafe_allow_html=True)
    with c4:
        st.caption("Payload User")
        st.markdown(kpi_pill(str(tech.get("PayloadUser", "--")), "ok"), unsafe_allow_html=True)


def joints_panel(latest: Dict[str, Any]) -> None:
    op = latest.get("OperationalData", {}) if isinstance(latest, dict) else {}
    cols = st.columns(4)
    labels = ["JointPosition1", "JointPosition2", "JointPosition3", "JointPosition4"]
    for i, name in enumerate(labels):
        vals = op.get(name)
        if isinstance(vals, list) and vals:
            try:
                avg = sum(float(v) for v in vals) / len(vals)
                txt = f"{avg:.1f}°"
            except Exception:
                txt = "--"
        else:
            txt = "--"
        with cols[i]:
            st.metric(label=name, value=txt)


def plot_timeseries(rows: Sequence[Tuple[str, float]]) -> None:
    # Try Altair for better visuals; fall back to st.line_chart
    try:
        import pandas as pd  # type: ignore
        import altair as alt  # type: ignore

        if not rows:
            st.info("Sem dados de histórico para exibir.")
            return
        df = pd.DataFrame(rows, columns=["t", "v"])  # t as ISO string
        df["t"] = pd.to_datetime(df["t"], errors="coerce")
        line = (
            alt.Chart(df)
            .mark_line(color="#16c266")
            .encode(x=alt.X("t:T", title="Tempo"), y=alt.Y("v:Q", title="Valor"))
            .properties(height=260)
        )
        st.altair_chart(line, use_container_width=True)
    except Exception:
        st.line_chart([v for (_, v) in rows], height=260)


# -------------------- App --------------------

def main() -> None:
    st.title("SCARA Dashboard")

    # Sidebar controls
    st.sidebar.header("Configuração")
    latest_path = st.sidebar.text_input("Arquivo de snapshot (latest_data.json)", str(DEFAULT_LATEST))
    db_path = st.sidebar.text_input("Banco SQLite (aas_history.sqlite3)", str(DEFAULT_DB))
    auto = st.sidebar.checkbox("Atualização automática", value=True)
    interval_ms = st.sidebar.slider(
        "Intervalo de atualização (ms)", min_value=500, max_value=5000, value=2000, step=500
    )
    if auto:
        secs = max(1, int(interval_ms / 1000))
        # Fallback simples: força reload da página no navegador
        st.markdown(
            f"<meta http-equiv='refresh' content='{secs}'>",
            unsafe_allow_html=True,
        )

    # Current snapshot
    latest = load_latest(latest_path)
    st.subheader("Status Atual")
    col_metrics(latest)
    with st.expander("Juntas (médias) ", expanded=True):
        joints_panel(latest)

    # History
    st.subheader("Histórico")
    paths = list_paths(db_path)
    if not paths:
        st.info("Nenhum caminho disponível em timeseries.")
    else:
        left, right = st.columns([2, 1])
        with left:
            options = [f"{sm} | {p}" for (sm, p) in paths]
            idx = st.selectbox("Métrica", options=list(range(len(options))), format_func=lambda i: options[i] if options else "", index=0)
        with right:
            limit = st.slider("Máximo de pontos", min_value=50, max_value=2000, value=300, step=50)

        if paths:
            sm, ep = paths[idx]
            rows = load_timeseries(db_path, sm, ep, limit)
            plot_timeseries(rows)
            st.caption(f"{sm} · {ep} · {len(rows)} pontos")

    # Raw JSON
    with st.expander("JSON bruto (latest_data.json)"):
        st.json(latest)

    st.markdown(
        """
        <hr style='opacity:.2'>
        <small style='color:#7a8598;'>
        Dica: rode <code>client_asyncua.py</code> para popular o snapshot e o histórico.
        </small>
        """,
        unsafe_allow_html=True,
    )


if __name__ == "__main__":
    main()

